[probe_eddy_current fly_eddy_probe]
sensor_type: ldc1612
i2c_address: 43
i2c_mcu: toolhead
i2c_bus: i2c1b
x_offset: 0     #记得设置x偏移
y_offset: 21.42 #记得设置y偏移 
z_offset: 2     #记得设置z偏移
i2c_speed: 4000000

[temperature_probe fly_eddy_probe]
sensor_type: Generic 3950
sensor_pin:toolhead:gpio28
horizontal_move_z: 4

[gcode_macro _LDC_CALIBRATE_DRIVE_CURRENT]
gcode:
    BED_MESH_CLEAR
    SET_KINEMATIC_POSITION x=100 y=100 z=10
    G28 X Y
    M104 S0
    M140 S0
    M106 S0
    G0 X{printer.toolhead.axis_maximum.x / 2} Y{printer.toolhead.axis_maximum.y / 2} F6000
    G0 Z30 F600
    G4 P1000
    LDC_CALIBRATE_DRIVE_CURRENT CHIP=fly_eddy_probe 
    G4 P1000
    SAVE_CONFIG

[gcode_macro PROBE_EDDY_CURRENT_CALIBRATE_AUTO]
gcode:
    BED_MESH_CLEAR
    G28 X Y
    M104 S0
    M140 S0
    M106 S0
    G90 # Abs positioning
    G1 X{ printer.toolhead.axis_maximum.x/2 } Y{ printer.toolhead.axis_maximum.y/2 } F6000
    {% if 'z' not in printer.toolhead.homed_axes %}
        SET_KINEMATIC_POSITION Z={ printer.toolhead.axis_maximum.z-1 } # Allows the user to work it down until it touches.
    {% endif %}
    PROBE_EDDY_CURRENT_CALIBRATE {rawparams}

[gcode_macro QUAD_GANTRY_LEVEL]
rename_existing: _QUAD_GANTRY_LEVEL 
gcode:
    {action_respond_info("FLY QGL...")}
    # ========== State Save ==========
    SAVE_GCODE_STATE NAME=STATE_QGL 
    
    # ========== Environment Preparation ==========
    BED_MESH_CLEAR                       # Clear existing bed mesh data 
    
    # ========== Main Leveling Process ==========
    {% if not printer.quad_gantry_level.applied %}
        # Initial coarse adjustment 
        _QUAD_GANTRY_LEVEL horizontal_move_z=10 retry_tolerance=1
    {% endif %}
    
    # Fine secondary leveling 
    _QUAD_GANTRY_LEVEL horizontal_move_z=2 retry_tolerance=0.075 retries=20 METHOD=rapid_scan ADAPTIVE=1
        G0 Z10 F6000                     # Use standard G-code commands instead of HORIZONTAL_MOVE_Z

    # ========== Post-Processing ==========
    G90                                 # Force absolute coordinate mode 
    G0 Z10 F6000                        # Raise Z axis to safe height 
    M117 QGL Completed                  # Display completion status 
    G28                                 # Return to origin
    # ========== State Restore ==========
    RESTORE_GCODE_STATE NAME=STATE_QGL 
    M400 

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: _BED_MESH_CALIBRATE
gcode:
    {action_respond_info("FLY BED_MESH_CALIBRATE...")}
    {% set TARGET_TEMP = printer.heater_bed.target %}
    M140 S0
    _BED_MESH_CALIBRATE horizontal_move_z=2 METHOD=rapid_scan {rawparams}
    M140 S{TARGET_TEMP}

# 若将Eddy同时用作探头和归位限位开关，并想使用测试版Z偏移控制
[delayed_gcode RESTORE_PROBE_OFFSET]  # 延迟G代码：恢复探头偏移量
initial_duration: 1  # 初始延迟时间(秒)
gcode:
  {% set svv = printer.save_variables.variables %}
  {% if not printer["gcode_macro SET_GCODE_OFFSET"].restored %}
    SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=runtime_offset VALUE={ svv.nvm_offset|default(0) }
    SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=restored VALUE=True
  {% endif %}

# 若将Eddy同时用作探头和归位限位开关
[gcode_macro G28]  # 归位宏命令
rename_existing: G28.1  # 重命名原有命令
gcode:
  G28.1 {rawparams}  # 执行原始归位命令
  {% if not rawparams or (rawparams and 'Z' in rawparams) %}
    PROBE  # 执行探头校准
    SET_Z_FROM_PROBE  # 根据探头结果设置Z轴位置
  {% endif %}

# 若将Eddy同时用作探头和归位限位开关
[gcode_macro SET_Z_FROM_PROBE]  # 根据探头结果设置Z轴
gcode:
    {% set homing_zhop = printer["gcode_macro _USER_VARIABLES"].homing_zhop|float|abs %}
    {% set cf = printer.configfile.settings %}
    SET_GCODE_OFFSET_ORIG Z={printer.probe.last_z_result - cf['probe_eddy_current fly_eddy_probe'].z_offset + printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset}
    G90  # 切换为绝对坐标模式
    G1 Z{homing_zhop}  # Z轴抬升至安全高度

# 若将Eddy同时用作探头和归位限位开关，并想使用测试版Z偏移控制
[gcode_macro Z_OFFSET_APPLY_PROBE]  # Z偏移量应用宏
rename_existing: Z_OFFSET_APPLY_PROBE_ORIG  # 重命名原有命令
gcode:
  SAVE_VARIABLE VARIABLE=nvm_offset VALUE={ printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset }  # 保存偏移量到变量
  RESPOND TYPE=echo MSG="保存成功"

# 若将Eddy同时用作探头和归位限位开关，并想使用测试版Z偏移控制
[gcode_macro SET_GCODE_OFFSET]  # G代码偏移设置宏
rename_existing: SET_GCODE_OFFSET_ORIG  # 重命名原有命令
variable_restored: False  # 标记变量是否已从非易失存储器恢复
variable_runtime_offset: 0  # 运行时偏移量
gcode:
  {% if params.Z_ADJUST %}  # 如果存在Z轴调整参数
    SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=runtime_offset VALUE={ printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset + params.Z_ADJUST|float }
  {% endif %}
  {% if params.Z %} 
    {% set paramList = rawparams.split() %}
    {% for i in range(paramList|length) %}
      {% if paramList[i]=="Z=0" %}
        {% set temp=paramList.pop(i) %}
        {% set temp="Z_ADJUST=" + (-printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset)|string %}
        {% if paramList.append(temp) %}{% endif %}
      {% endif %}
    {% endfor %}
    {% set rawparams=paramList|join(' ') %}
    SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=runtime_offset VALUE=0
  {% endif %}
  SET_GCODE_OFFSET_ORIG { rawparams }  # 执行原始偏移设置命令

[gcode_macro _USER_VARIABLES]
variable_probe_type_enabled: "inductive_virtual"
# variable_startprint_actions: "bed_soak", "extruder_preheating", "chamber_soak", "tilt_calib", "clean", "z_offset", "bedmesh", "extruder_heating", "primeline"
variable_startprint_actions: "bed_soak", "extruder_preheating", "chamber_soak", "tilt_calib", "clean", "bedmesh", "extruder_heating", "clean", "primeline"
# variable_startprint_actions: "bed_soak", "extruder_preheating", "chamber_soak", "tilt_calib", "clean", "z_offset", "extruder_heating", "clean", "primeline"
gcode:

[include ../../../macros/base/probing/generic_probe.cfg]

[gcode_macro _MODULE_BED_MESH]
gcode:
    # ----- BED MESH -------------------------------------------
    {% set FL_SIZE = printer["gcode_macro START_PRINT"].fl_size %}
    {% set BED_MESH_PROFILE = printer["gcode_macro START_PRINT"].bed_mesh_profile %}

    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set bed_mesh_enabled = printer["gcode_macro _USER_VARIABLES"].bed_mesh_enabled %}
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}

    {% if bed_mesh_enabled %}
        {% if BED_MESH_PROFILE == "" %}
            {% if verbose %}
                RESPOND MSG="Bed mesh measurement..."
            {% endif %}
            # ADAPTIVE_BED_MESH SIZE={FL_SIZE}
            BED_MESH_CALIBRATE
        {% else %}
            {% if verbose %}
                RESPOND MSG="Load bed mesh profile : {BED_MESH_PROFILE}"
            {% endif %}
            BED_MESH_PROFILE LOAD={BED_MESH_PROFILE}
        {% endif %}
    {% endif %}


# Quand gantry leveling definition
# If this files is included, then it also activate the QGL
# automatically in the START_PRINT macro
[gcode_macro _USER_VARIABLES]
variable_qgl_enabled: True
gcode:

# Also include directly the dockable probe overide of qgl from here
# [include ../../../macros/base/probing/overrides/qgl.cfg]
[include ../../../macros/base/homing/tilting.cfg]


[quad_gantry_level]
gantry_corners:
    -60,-10
    410,420
points:
    50,25
    50,275
    300,275
    300,25
speed: 350
horizontal_move_z: 12
retries: 5
retry_tolerance: 0.0075
max_adjust: 10

# If this files is included, then it also activate the bed_mesh
# automatically in the START_PRINT macro
[gcode_macro _USER_VARIABLES]
variable_bed_mesh_enabled: True
gcode:

# Also include directly the dockable probe overide of BED_MESH_CALIBRATE from here
# [include ../../../macros/base/probing/overrides/bed_mesh_calibrate.cfg]
# And also include the adaptive mesh macro at the same time
# [include ../../../macros/calibration/adaptive_bed_mesh.cfg]


[bed_mesh]
speed: 350
horizontal_move_z: 20
mesh_min: 25, 25
mesh_max: 325, 325
probe_count: 9, 9
fade_start: 0.6
fade_end: 10.0
algorithm: bicubic
zero_reference_position: 175, 175
adaptive_margin: 5



[stepper_z]
endstop_pin: probe:z_virtual_endstop

# Homing Override for dockable probe
[homing_override]
axes: xyz
gcode:
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set kinematics = printer["configfile"].config["printer"]["kinematics"] %}
    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    {% set homing_zhop = printer["gcode_macro _USER_VARIABLES"].homing_zhop|float|abs %}
    {% set homing_travel_speed = printer["gcode_macro _USER_VARIABLES"].homing_travel_speed * 60 %}
    {% set homing_travel_accel = printer["gcode_macro _USER_VARIABLES"].homing_travel_accel %}
    {% set sensorless_homing_enabled = printer["gcode_macro _USER_VARIABLES"].sensorless_homing_enabled %}
    {% set sensorless_current_factor = printer["gcode_macro _USER_VARIABLES"].sensorless_current_factor / 100 %}
    {% set x_driver = printer["gcode_macro _USER_VARIABLES"].x_driver %}
    {% set y_driver = printer["gcode_macro _USER_VARIABLES"].y_driver %}
    {% set z_driver = printer["gcode_macro _USER_VARIABLES"].z_driver %}
    {% set z_drop_speed = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}
    {% set bed_mesh_enabled = printer["gcode_macro _USER_VARIABLES"].bed_mesh_enabled %}

    {% set homing_first = printer["gcode_macro _USER_VARIABLES"].homing_first|string|upper %}
    {% set x_homing_backoff, y_homing_backoff = printer["gcode_macro _USER_VARIABLES"].homing_backoff_distance_xy|map('float') %}

    {% set x_position_endstop = printer["configfile"].config["stepper_x"]["position_endstop"]|float %}
    {% set y_position_endstop = printer["configfile"].config["stepper_y"]["position_endstop"]|float %}
    {% set x_position_center = printer.toolhead.axis_maximum.x|int/2 - printer.toolhead.axis_minimum.x|int/2 %}
    {% set y_position_center = printer.toolhead.axis_maximum.y|int/2 - printer.toolhead.axis_minimum.y|int/2 %}


    {% if probe_type_enabled == "dockable" or probe_type_enabled == "dockable_virtual" %}
        _CHECK_PROBE action=query
    {% endif %}

    # reset parameters
    {% set X, Y, Z = False, False, False %}

    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="HOMING"
    {% endif %}

    # which axes have been requested for homing
    {% if not 'X' in params
        and not 'Y' in params
        and not 'Z' in params %}

        {% set X, Y, Z = True, True, True %}

    {% else %}
        {% if 'X' in params %}
            {% set X = True %}
        {% endif %}

        {% if 'Y' in params %}
            {% set Y = True %}
        {% endif %}

        {% if 'Z' in params %}
            {% set Z = True %}
        {% endif %}

        {% if 'X' in params
          and 'Y' in params
          and 'Z' in params %}
            # reset homing state variables
            # if homing all axes
            _HOMING_VARIABLES reset=1
         {% endif %}

    {% endif %}

    {% if probe_type_enabled == "dockable" or probe_type_enabled == "dockable_virtual" %}
       _ENTRY_POINT FUNCTION=homing_override
    {% endif %}

    # Set the homing acceleration prior to any movement
    {% set saved_accel = printer.toolhead.max_accel %}
    M204 S{homing_travel_accel}

    {% if bed_mesh_enabled %}
        BED_MESH_CLEAR
    {% endif %}

    G90

    {% if Z %}
        {% if ('z' in printer.toolhead.homed_axes) %}
            {% if (printer.toolhead.position.z < homing_zhop) %}
                {% if verbose %}
                    { action_respond_info("Z too low, performing ZHOP to rehome Z") }
                {% endif %}
                G91
                G0 Z{homing_zhop} F{z_drop_speed}
                M400
                G90
            {% else %}
                {% if verbose %}
                    { action_respond_info("Z already safe, no ZHOP needed to rehome Z") }
                {% endif %}
            {% endif %}
        {% elif ('xy' in printer.toolhead.homed_axes) %}
            {% if verbose %}
                { action_respond_info("X and Y already homed, no ZHOP needed to home Z") }
            {% endif %}
        {% else %}
            {% if verbose %}
                { action_respond_info("X and Y not homed, forcing full G28 to home Z properly") }
            {% endif %}
            SET_KINEMATIC_POSITION X=0 Y=0 Z=0
            G0 Z{homing_zhop} F{z_drop_speed}
            {% if sensorless_homing_enabled and kinematics == "corexz" %}
                # Wait for stallguard registers to clear
                M400
            {% endif %}
            {% set X, Y, Z = True, True, True %}
        {% endif %}
    {% endif %}

    {% if homing_first == "X" %}
        {% if X %} # Home x
            {% if verbose %}
                { action_respond_info("Homing X") }
            {% endif %}
            {% if sensorless_homing_enabled %}
                {% if kinematics == "corexy" %}
                    {% set old_current_x = printer.configfile.config[x_driver ~ ' stepper_x'].run_current|float %}
                    {% set old_current_y = printer.configfile.config[y_driver ~ ' stepper_y'].run_current|float %}
                    {% set new_current_x = sensorless_current_factor * old_current_x %}
                    {% set new_current_y = sensorless_current_factor * old_current_y %}
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={new_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={new_current_y}
                    M400
                {% elif kinematics == "corexz" %}
                    {% set old_current_x = printer.configfile.config[x_driver ~ ' stepper_x'].run_current|float %}
                    {% set old_current_z = printer.configfile.config[z_driver ~ ' stepper_z'].run_current|float %}
                    {% set new_current_x = sensorless_current_factor * old_current_x %}
                    {% set new_current_z = sensorless_current_factor * old_current_z %}
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={new_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_z CURRENT={new_current_z}
                    M400
                {% elif kinematics == "cartesian" %}
                    {% set old_current_x = printer.configfile.config[x_driver ~ ' stepper_x'].run_current|float %}
                    {% set new_current_x = sensorless_current_factor * old_current_x %}
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={new_current_x}
                    M400
                {% endif %}
            {% endif %}
            G28.1 X0
            G1 X{x_position_endstop + x_homing_backoff} F{homing_travel_speed}
            {% if sensorless_homing_enabled %}
                {% if kinematics == "corexy" %}
                    M400
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={old_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={old_current_y}
                {% elif kinematics == "corexz" %}
                    M400
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={old_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_z CURRENT={old_current_z}
                {% elif kinematics == "cartesian" %}
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={old_current_x}
                {% endif %}
            {% endif %}
        {% endif %}
        {% if Y %} # Home y
            {% if verbose %}
                { action_respond_info("Homing Y") }
            {% endif %}
            {% if sensorless_homing_enabled %}
                {% if kinematics == "corexy" %}
                    {% set old_current_x = printer.configfile.config[x_driver ~ ' stepper_x'].run_current|float %}
                    {% set old_current_y = printer.configfile.config[y_driver ~ ' stepper_y'].run_current|float %}
                    {% set new_current_x = sensorless_current_factor * old_current_x %}
                    {% set new_current_y = sensorless_current_factor * old_current_y %}
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={new_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={new_current_y}
                    M400
                {% elif kinematics == "corexz" %}
                    {% set old_current_y = printer.configfile.config[y_driver ~ ' stepper_y'].run_current|float %}
                    {% set new_current_y = sensorless_current_factor * old_current_y %}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={new_current_y}
                    M400
                {% elif kinematics == "cartesian" %}
                    {% set old_current_y = printer.configfile.config[y_driver ~ ' stepper_y'].run_current|float %}
                    {% set new_current_y = sensorless_current_factor * old_current_y %}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={new_current_y}
                    M400
                {% endif %}
            {% endif %}
            G28.1 Y0
            G1 Y{y_position_endstop + y_homing_backoff} F{homing_travel_speed}
            {% if sensorless_homing_enabled %}
                {% if kinematics == "corexy" %}
                    M400
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={old_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={old_current_y}
                {% elif kinematics == "corexz" %}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={old_current_y}
                {% elif kinematics == "cartesian" %}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={old_current_y}
                {% endif %}
            {% endif %}
        {% endif %}

    {% elif homing_first == "Y" %}
        {% if Y %} # Home y
            {% if verbose %}
                { action_respond_info("Homing Y") }
            {% endif %}
            {% if sensorless_homing_enabled %}
                {% if kinematics == "corexy" %}
                    {% set old_current_x = printer.configfile.config[x_driver ~ ' stepper_x'].run_current|float %}
                    {% set old_current_y = printer.configfile.config[y_driver ~ ' stepper_y'].run_current|float %}
                    {% set new_current_x = sensorless_current_factor * old_current_x %}
                    {% set new_current_y = sensorless_current_factor * old_current_y %}
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={new_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={new_current_y}
                    M400
                {% elif kinematics == "corexz" %}
                    {% set old_current_y = printer.configfile.config[y_driver ~ ' stepper_y'].run_current|float %}
                    {% set new_current_y = sensorless_current_factor * old_current_y %}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={new_current_y}
                    M400
                {% elif kinematics == "cartesian" %}
                    {% set old_current_y = printer.configfile.config[y_driver ~ ' stepper_y'].run_current|float %}
                    {% set new_current_y = sensorless_current_factor * old_current_y %}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={new_current_y}
                    M400
                {% endif %}
            {% endif %}
            G28.1 Y0
            G1 Y{y_position_endstop + y_homing_backoff} F{homing_travel_speed}
            {% if sensorless_homing_enabled %}
                {% if kinematics == "corexy" %}
                    M400
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={old_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={old_current_y}
                {% elif kinematics == "corexz" %}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={old_current_y}
                {% elif kinematics == "cartesian" %}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={old_current_y}
                {% endif %}
            {% endif %}
        {% endif %}
        {% if X %} # Home x
            {% if verbose %}
                { action_respond_info("Homing X") }
            {% endif %}
            {% if sensorless_homing_enabled %}
                {% if kinematics == "corexy" %}
                    {% set old_current_x = printer.configfile.config[x_driver ~ ' stepper_x'].run_current|float %}
                    {% set old_current_y = printer.configfile.config[y_driver ~ ' stepper_y'].run_current|float %}
                    {% set new_current_x = sensorless_current_factor * old_current_x %}
                    {% set new_current_y = sensorless_current_factor * old_current_y %}
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={new_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={new_current_y}
                    M400
                {% elif kinematics == "corexz" %}
                    {% set old_current_x = printer.configfile.config[x_driver ~ ' stepper_x'].run_current|float %}
                    {% set old_current_z = printer.configfile.config[z_driver ~ ' stepper_z'].run_current|float %}
                    {% set new_current_x = sensorless_current_factor * old_current_x %}
                    {% set new_current_z = sensorless_current_factor * old_current_z %}
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={new_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_z CURRENT={new_current_z}
                    M400
                {% elif kinematics == "cartesian" %}
                    {% set old_current_x = printer.configfile.config[x_driver ~ ' stepper_x'].run_current|float %}
                    {% set new_current_x = sensorless_current_factor * old_current_x %}
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={new_current_x}
                    M400
                {% endif %}
            {% endif %}
            G28.1 X0
            G1 X{x_position_endstop + x_homing_backoff} F{homing_travel_speed}
            {% if sensorless_homing_enabled %}
                {% if kinematics == "corexy" %}
                    M400
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={old_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={old_current_y}
                {% elif kinematics == "corexz" %}
                    M400
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={old_current_x}
                    SET_TMC_CURRENT STEPPER=stepper_z CURRENT={old_current_z}
                {% elif kinematics == "cartesian" %}
                    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={old_current_x}
                {% endif %}
            {% endif %}
        {% endif %}

    {% else %}
        { action_respond_error("Axis homing order not valid. Choose either X or Y first in the variables.cfg file!") }
    {% endif %}


    # Home z
    {% if Z %}
        {% if verbose %}
            { action_respond_info("Homing Z") }
        {% endif %}

        # If there is a virtual probe endstop (ie. TAP or inductive as virtual), we go to the center of the bed
        # If the Z endstop is not virtual, then we just move to it
        {% if printer["configfile"].config["stepper_z"]["endstop_pin"]|lower == "probe:z_virtual_endstop" %}
            # If our virtual endstop is a dockable probe, we need to activate it first
            # If it's the voron tap, we put it to a safe temperature
            {% if probe_type_enabled == "dockable_virtual" or probe_type_enabled == "vorontap" %}
                ACTIVATE_PROBE
            {% endif %}

            # If there is a bed_mesh enabled and a zero_reference_position set, we retrieve it to home on it
            # Else, we default to the center of the bed
            {% if not bed_mesh_enabled or not printer["configfile"].config["bed_mesh"]["zero_reference_position"] %}
                G0 X{x_position_center} Y{y_position_center} F{homing_travel_speed}
            {% else %}
                {% set ZRPx, ZRPy = printer["configfile"].config["bed_mesh"]["zero_reference_position"].split(',')|map('trim')|map('float') %}
                G0 X{ZRPx} Y{ZRPy} F{homing_travel_speed}
            {% endif %}

        # Else, go to the Z endstop physical pin
        {% else %}
            _GOTO_Z_PROBE
        {% endif %}

        G28.1 Z0

        G91
        {% if printer["configfile"].settings["stepper_z"]["homing_positive_dir"] == False %}
            G0 Z{homing_zhop} F{z_drop_speed} # small Z hop to avoid grinding the bed (as we should be close to Z0 right now)
        {% elif printer["configfile"].settings["stepper_z"]["homing_positive_dir"] == True %}
            G0 Z-{homing_zhop} F{z_drop_speed} # small Z move in the opposite direction to avoid staying on the endstop (not dangerous since we should be at Z max)
        {% endif %}
        G90

        # if voron tap, restore original temperature
        # if dockable probe as virtual endstop, then dock the probe
        {% if probe_type_enabled == "vorontap" or probe_type_enabled == "dockable_virtual" %}
            DEACTIVATE_PROBE
        {% endif %}
    {% endif %}

    {% if probe_type_enabled == "dockable" or probe_type_enabled == "dockable_virtual" %}
        _CHECK_PROBE action=query
    {% endif %}

    # Reset acceleration values to what it was before
    SET_VELOCITY_LIMIT ACCEL={saved_accel}

    {% if probe_type_enabled == "dockable" or probe_type_enabled == "dockable_virtual" %}
        _EXIT_POINT FUNCTION=homing_override
    {% endif %}

    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="READY"
    {% endif %}